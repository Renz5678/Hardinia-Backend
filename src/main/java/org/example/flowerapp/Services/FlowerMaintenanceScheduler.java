package org.example.flowerapp.Services;

import lombok.extern.slf4j.Slf4j;
import org.example.flowerapp.Models.Enums.MaintenanceType;
import org.example.flowerapp.Models.Flower;
import org.example.flowerapp.Models.Maintenance;
import org.example.flowerapp.Repository.FlowerRepository;
import org.example.flowerapp.Repository.MaintenanceRepository;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Service
@Slf4j
public class FlowerMaintenanceScheduler {

    private final FlowerRepository flowerRepository;
    private final MaintenanceRepository maintenanceRepository;

    public FlowerMaintenanceScheduler(FlowerRepository flowerRepository,
                                      MaintenanceRepository maintenanceRepository) {
        this.flowerRepository = flowerRepository;
        this.maintenanceRepository = maintenanceRepository;
    }

    @Scheduled(cron = "0 0 6 * * *") // 6 AM daily
    @Transactional
    public void scheduleMaintenanceTasks() {
        log.info("Running scheduled maintenance task generation...");

        List<Flower> flowers = flowerRepository.findAllFlower();
        LocalDateTime now = LocalDateTime.now();

        for (Flower flower : flowers) {
            checkAndScheduleWatering(flower, now);
            checkAndScheduleFertilizing(flower, now);
            checkAndSchedulePruning(flower, now);
        }

        log.info("Completed maintenance task generation");
    }

    private void checkAndScheduleWatering(Flower flower, LocalDateTime now) {
        if (flower.getWaterFrequencyDays() == null) return;

        if (!flower.isAutoScheduling()) return;

        LocalDateTime nextWaterDate = flower.getLastWateredDate() != null
                ? flower.getLastWateredDate().plusDays(flower.getWaterFrequencyDays())
                : flower.getPlantingDate();

        if (now.isAfter(nextWaterDate) && !taskExistsForToday(flower, MaintenanceType.WATERING)) {
            createMaintenanceTask(flower, MaintenanceType.WATERING, now);
        }
    }

    private void checkAndScheduleFertilizing(Flower flower, LocalDateTime now) {
        if (flower.getFertilizeFrequencyDays() == null) return;

        if (!flower.isAutoScheduling()) return;

        LocalDateTime nextFertilizeDate = flower.getLastFertilizedDate() != null
                ? flower.getLastFertilizedDate().plusDays(flower.getFertilizeFrequencyDays())
                : flower.getPlantingDate().plusDays(flower.getFertilizeFrequencyDays());

        if (now.isAfter(nextFertilizeDate) && !taskExistsForToday(flower, MaintenanceType.FERTILIZING)) {
            createMaintenanceTask(flower, MaintenanceType.FERTILIZING, now);
        }
    }

    private void checkAndSchedulePruning(Flower flower, LocalDateTime now) {
        if (flower.getPruneFrequencyDays() == null) return;

        if (!flower.isAutoScheduling()) return;

        LocalDateTime nextPruneDate = flower.getLastPrunedDate() != null
                ? flower.getLastPrunedDate().plusDays(flower.getPruneFrequencyDays())
                : flower.getPlantingDate().plusDays(flower.getPruneFrequencyDays());

        if (now.isAfter(nextPruneDate) && !taskExistsForToday(flower, MaintenanceType.PRUNING)) {
            createMaintenanceTask(flower, MaintenanceType.PRUNING, now);
        }
    }

    private boolean taskExistsForToday(Flower flower, MaintenanceType type) {
        LocalDateTime startOfDay = LocalDateTime.now().toLocalDate().atStartOfDay();
        LocalDateTime endOfDay = startOfDay.plusDays(1);

        return maintenanceRepository.existsByFlowerAndTypeAndDateRange(
                flower.getFlower_id(), type, startOfDay, endOfDay
        );
    }

    private void createMaintenanceTask(Flower flower, MaintenanceType type, LocalDateTime scheduledDate) {
        Maintenance task = new Maintenance();
        task.setFlower(flower);
        task.setTaskType(type);
        task.setScheduledDate(scheduledDate);
        task.setAutoGenerated(true);
        task.setCompleted(false);
        task.setCreatedAt(LocalDateTime.now());
        task.setNotes("Auto-generated " + type.getMaintenanceType() + " task for " + flower.getFlowerName());

        maintenanceRepository.save(task);
        log.info("Created {} task for flower: {}", type.getMaintenanceType(), flower.getFlowerName());
    }
}
